/**
 * ENHANCED TITLE MATCHING - COPY TO YOUR CombinedMovieRepository.kt
 * 
 * Replace your existing titlesMatch() and cleanTitle() methods with these enhanced versions
 * to significantly improve TMDB-Supabase movie matching success rate.
 */

// 1. ENHANCED CLEAN TITLE METHOD
// Replace your existing cleanTitle() method with this one:
fun cleanTitle(title: String): String {
    return title
        .lowercase()
        // Remove common articles at start
        .replace(Regex("^(the|a|an)\\s+"), "") 
        // Remove years at end in various formats
        .replace(Regex("\\s*[\\(\\[]\\d{4}[\\)\\]]*\\s*$"), "")
        // Remove common movie suffixes and editions
        .replace(Regex("\\s*(director's cut|extended|unrated|theatrical|special edition|remastered|4k|hd|bluray|dvd)\\s*$"), "")
        // Remove special characters and punctuation but keep spaces
        .replace(Regex("[^a-z0-9\\s]"), " ")
        // Normalize multiple spaces to single space
        .replace(Regex("\\s+"), " ")
        // Remove common movie number patterns
        .replace(Regex("\\s+(part|vol|volume|chapter)\\s*\\d+\\s*$"), "")
        .trim()
}

// 2. ENHANCED TITLES MATCH METHOD
// Replace your existing titlesMatch() method with this one:
private fun titlesMatch(tmdbTitle: String, supabaseTitle: String): Boolean {
    // Strategy 1: Exact match (case insensitive)
    if (tmdbTitle.equals(supabaseTitle, ignoreCase = true)) {
        return true
    }
    
    // Strategy 2: Clean title match
    val cleanTmdb = cleanTitle(tmdbTitle)
    val cleanSupabase = cleanTitle(supabaseTitle)
    if (cleanTmdb == cleanSupabase && cleanTmdb.isNotEmpty()) {
        return true
    }
    
    // Strategy 3: Similarity match (lowered threshold from 75% to 60%)
    val similarity = calculateSimilarity(tmdbTitle, supabaseTitle)
    if (similarity >= 0.60) { // Lowered threshold for more matches
        return true
    }
    
    // Strategy 4: Enhanced keyword matching (more flexible)
    val lowerTmdb = tmdbTitle.lowercase()
    val lowerSupabase = supabaseTitle.lowercase()
    
    if (lowerTmdb.length >= 3 && lowerSupabase.length >= 3) {
        if ((lowerTmdb.contains(lowerSupabase) && lowerSupabase.length >= lowerTmdb.length * 0.4) ||
            (lowerSupabase.contains(lowerTmdb) && lowerTmdb.length >= lowerSupabase.length * 0.4)) {
            return true
        }
    }
    
    // Strategy 5: Word overlap (more flexible)
    val tmdbWords = cleanTmdb.split(" ").filter { it.length > 1 }
    val supabaseWords = cleanSupabase.split(" ").filter { it.length > 1 }
    
    if (tmdbWords.isNotEmpty() && supabaseWords.isNotEmpty()) {
        val matchingWords = tmdbWords.intersect(supabaseWords.toSet()).size
        val totalWords = maxOf(tmdbWords.size, supabaseWords.size)
        if (matchingWords.toDouble() / totalWords >= 0.5) { // Lowered from 0.6
            return true
        }
    }
    
    // Strategy 6: Partial substring matching (new)
    if (cleanTmdb.length >= 4 && cleanSupabase.length >= 4) {
        val shorter = if (cleanTmdb.length < cleanSupabase.length) cleanTmdb else cleanSupabase
        val longer = if (cleanTmdb.length < cleanSupabase.length) cleanSupabase else cleanTmdb
        
        if (longer.contains(shorter) && shorter.length >= longer.length * 0.5) {
            return true
        }
    }
    
    return false
}

// 3. ENHANCED FIND BEST MATCH METHOD
// Replace your findBestMatch() method with this enhanced version:
private fun findBestMatch(tmdbMovie: Movie, supabaseMovies: List<SupabaseMovie>): SupabaseMovie? {
    if (supabaseMovies.isEmpty()) return null
    
    var bestMatch: SupabaseMovie? = null
    var bestScore = 0.0
    
    for (supabaseMovie in supabaseMovies) {
        // Skip movies without valid video URLs
        if (!supabaseMovie.hasValidVideoUrl()) {
            continue
        }
        
        // Strategy 1: Exact title match (case insensitive)
        if (tmdbMovie.title.equals(supabaseMovie.title, ignoreCase = true)) {
            return supabaseMovie // Perfect match, return immediately
        }
        
        // Strategy 2: Clean title match
        val cleanTmdb = cleanTitle(tmdbMovie.title)
        val cleanSupabase = cleanTitle(supabaseMovie.title)
        if (cleanTmdb == cleanSupabase && cleanTmdb.isNotEmpty()) {
            return supabaseMovie // Perfect clean match
        }
        
        // Strategy 3: Year-tolerant matching
        val tmdbNoYear = tmdbMovie.title.replace(Regex("\\s*\\(\\d{4}\\)\\s*$"), "").trim()
        val supabaseNoYear = supabaseMovie.title.replace(Regex("\\s*\\(\\d{4}\\)\\s*$"), "").trim()
        if (tmdbNoYear.equals(supabaseNoYear, ignoreCase = true) && tmdbNoYear.isNotEmpty()) {
            return supabaseMovie
        }
        
        // Strategy 4: Advanced similarity matching
        if (titlesMatch(tmdbMovie.title, supabaseMovie.title)) {
            val similarity = calculateSimilarity(tmdbMovie.title, supabaseMovie.title)
            
            if (similarity > bestScore) {
                bestScore = similarity
                bestMatch = supabaseMovie
                
                // If we found a very good match (85%+), consider it excellent
                if (similarity >= 0.85) {
                    return bestMatch
                }
            }
        }
    }
    
    // Final validation: Lowered threshold to catch more movies
    if (bestMatch != null && bestScore >= 0.50) { // Lowered from 0.65 to 0.50
        return bestMatch
    }
    
    return null
}

// 4. USAGE INSTRUCTIONS:
/*
1. Open your CombinedMovieRepository.kt file
2. Replace the cleanTitle() method with the enhanced version above
3. Replace the titlesMatch() method with the enhanced version above  
4. Replace the findBestMatch() method with the enhanced version above
5. Test your app - you should see significantly more movies with thumbnails and metadata

KEY IMPROVEMENTS:
- Lowered similarity thresholds from 75% to 60% and final threshold from 65% to 50%
- Enhanced title normalization (removes more movie suffixes and normalizes better)
- More flexible keyword matching (40% instead of 50% overlap required)
- Added partial substring matching strategy
- Better year handling
- More aggressive word overlap matching

EXPECTED RESULTS:
- Match success rate should increase from ~60-70% to 80-90%
- More movies will have thumbnails and metadata from TMDB
- Better handling of movie sequels, special editions, and variations
*/