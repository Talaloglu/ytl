name: Video Hosting Worker

on:
  schedule:
    - cron: "*/5 * * * *"  # every 5 minutes
  workflow_dispatch: {}

jobs:
  process-video-hosting-queue:
    name: Process Video Hosting Queue
    runs-on: self-hosted
    env:
      SB_FUNCTION_BASE_URL: ${{ vars.SB_FUNCTION_BASE_URL || 'https://kivsnvphztbywnwlffmb.functions.supabase.co/video_hosting_worker' }}
      R2_ACCOUNT_ID: ${{ vars.R2_ACCOUNT_ID }}
      R2_BUCKET: ${{ vars.R2_BUCKET }}
      R2_PUBLIC_BASE_URL: ${{ vars.R2_PUBLIC_BASE_URL }}
      R2_API_TOKEN: ${{ secrets.R2_API_TOKEN }}
      SB_ADMIN_TOKEN: ${{ secrets.SB_ADMIN_TOKEN }}
    steps:
      - name: Validate required secrets/vars
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $missing = @()
          if (-not $env:SB_ADMIN_TOKEN) { $missing += 'SB_ADMIN_TOKEN' }
          if (-not $env:R2_ACCOUNT_ID) { $missing += 'R2_ACCOUNT_ID' }
          if (-not $env:R2_BUCKET) { $missing += 'R2_BUCKET' }
          if (-not $env:R2_PUBLIC_BASE_URL) { $missing += 'R2_PUBLIC_BASE_URL' }
          if (-not $env:R2_API_TOKEN) { $missing += 'R2_API_TOKEN' }
          if ($missing.Count -gt 0) {
            Write-Error "Missing required secrets/vars: $($missing -join ', ')"
            exit 1
          }

      - name: Install dependencies
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          # Install jq if not present
          if (-not (Get-Command jq -ErrorAction SilentlyContinue)) {
            winget install --id jqlang.jq --accept-source-agreements --accept-package-agreements
          }
          # curl and unzip are usually available on Windows
          

      - name: Lease jobs
        id: lease
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $url = "$env:SB_FUNCTION_BASE_URL/lease"
          $headers = @{}
          $headers["x-admin-token"] = $env:SB_ADMIN_TOKEN
          $headers["Content-Type"] = "application/json"
          $body = '{"limit":3}'
          $response = Invoke-WebRequest -Uri $url -Method Post -Headers $headers -Body $body -ContentType "application/json"
          $response.Content | ConvertFrom-Json | ConvertTo-Json -Depth 10 | Out-File -FilePath "lease.json" -Encoding UTF8
          $responseContent = Get-Content "lease.json" -Raw
          Write-Host "response=$responseContent" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding UTF8

      - name: Process jobs
        if: always()
        shell: powershell
        run: |
          $ErrorActionPreference = 'Continue'
          Write-Host "Starting Process jobs step..."
          
          # Debug: Check if lease.json exists
          if (Test-Path "lease.json") {
            Write-Host "lease.json found"
            $rawContent = Get-Content "lease.json" -Raw
            Write-Host "Raw content: $rawContent"
          } else {
            Write-Host "ERROR: lease.json not found"
            exit 1
          }
          
          try {
            $leaseData = Get-Content "lease.json" | ConvertFrom-Json
            Write-Host "Parsed lease data successfully"
          } catch {
            Write-Host "ERROR parsing JSON: $($_.Exception.Message)"
            exit 1
          }
          
          if (-not $leaseData.jobs -or $leaseData.jobs.Count -eq 0) {
            Write-Host "Jobs array is empty or missing"
            if (-not $leaseData.jobs) {
              $leaseData | Add-Member -MemberType NoteProperty -Name jobs -Value @()
            }
          }
          
          $jobs = $leaseData.jobs
          $count = $jobs.Count
          Write-Host "Leased jobs count: $count"
          
          if ($count -eq 0) {
            Write-Host "No jobs to process."
            exit 0
          }
          
          Write-Host "Processing $count jobs..."
          
          function Process-Job {
            param([string]$jobJson)
            $job = $jobJson | ConvertFrom-Json
            $jobId = $job.id
            $movieId = $job.movie_id
            $tryCount = $job.try_count
            Write-Host "Processing job $jobId for movie $movieId (try $tryCount)"
            
            # Resolve fresh source URL + headers
            $resolveUrl = "$env:SB_FUNCTION_BASE_URL/resolve"
            $headers = @{}
            $headers["x-admin-token"] = $env:SB_ADMIN_TOKEN
            $headers["Content-Type"] = "application/json"
            $body = @{jobId = $jobId} | ConvertTo-Json -Compress
            try {
              $response = Invoke-WebRequest -Uri $resolveUrl -Method Post -Headers $headers -Body $body -ContentType "application/json"
              $resolved = $response.Content | ConvertFrom-Json
            } catch {
              $resolved = @{}
            }
            $sourceUrl = $resolved.sourceUrl
            if (-not $sourceUrl) {
              Write-Host "Resolve failed or no sourceUrl; rescheduling..."
              $rescheduleHeaders = @{}
              $rescheduleHeaders["x-admin-token"] = $env:SB_ADMIN_TOKEN
              $rescheduleHeaders["Content-Type"] = "application/json"
              $rescheduleBody = @{jobId = $jobId; tryCount = $tryCount; reason = "resolve_failed"} | ConvertTo-Json -Compress
              Invoke-WebRequest -Uri "$env:SB_FUNCTION_BASE_URL/reschedule" -Method Post -Headers $rescheduleHeaders -Body $rescheduleBody | Out-Null
              return
            }
            
            # Prepare cURL header config to avoid quoting issues
            $hdrCfg = "headers.cfg"
            $headerLines = @(
              'header = "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"'
              'header = "Referer: https://fatv.vip/"'
              'header = "Accept: */*"'
              'header = "Accept-Language: en-US,en;q=0.9"'
            )
            $headerLines | Out-File -FilePath $hdrCfg -Encoding UTF8
            
            # Temp file
            $ext = if ($sourceUrl -match '\.(mp4|mkv)(\?.*)?$') { $matches[1] } else { "mp4" }
            $tmpFile = "video_${jobId}.${ext}"
            
            # Try download up to 3 times with fresh resolve on 401/403
            $ok = $false
            for ($attempt = 1; $attempt -le 3; $attempt++) {
              Write-Host "Download attempt $attempt"
              # Resolve again for each attempt to refresh tokens
              try {
                $response = Invoke-WebRequest -Uri $resolveUrl -Method Post -Headers $headers -Body $body -ContentType "application/json"
                $resolved = $response.Content | ConvertFrom-Json
              } catch {
                $resolved = @{}
              }
              $sourceUrl = $resolved.sourceUrl
              # Using cURL config file for headers (see $hdrCfg)
              $httpCode = & curl -sSL -w '%{http_code}' -o "$tmpFile" -K "$hdrCfg" "$sourceUrl" 2>$null
              if ($httpCode -eq "200" -or $httpCode -eq "206") {
                $ok = $true
                break
              }
              if ($httpCode -eq "401" -or $httpCode -eq "403" -or $httpCode -eq "0") {
                Write-Host "Got $httpCode; will retry after re-resolve"
                Start-Sleep -Seconds 2
                continue
              }
              Write-Host "HTTP $httpCode not retryable"
              break
            }
            
            if (-not $ok) {
              Write-Host "Download failed; rescheduling"
              $rescheduleHeaders = @{}
              $rescheduleHeaders["x-admin-token"] = $env:SB_ADMIN_TOKEN
              $rescheduleHeaders["Content-Type"] = "application/json"
              $rescheduleBody = @{jobId = $jobId; tryCount = $tryCount; reason = "download_failed"} | ConvertTo-Json -Compress
              Invoke-WebRequest -Uri "$env:SB_FUNCTION_BASE_URL/reschedule" -Method Post -Headers $rescheduleHeaders -Body $rescheduleBody | Out-Null
              Remove-Item $tmpFile -ErrorAction SilentlyContinue
              Remove-Item $hdrCfg -ErrorAction SilentlyContinue
              return
            }
            
            # Upload to R2 via REST API
            $ts = [int](Get-Date -UFormat %s)
            $key = "movies/${movieId}/${ts}.${ext}"
            Write-Host "Uploading to r2://${env:R2_BUCKET}/${key}"
            
            # R2 REST API upload
            $uploadUrl = "https://${env:R2_ACCOUNT_ID}.r2.cloudflarestorage.com/${env:R2_BUCKET}/${key}"
            $uploadHeaders = @{}
            $uploadHeaders["Authorization"] = "Bearer $env:R2_API_TOKEN"
            $uploadHeaders["Content-Type"] = "video/$ext"
            
            # Upload file content
            $fileBytes = [System.IO.File]::ReadAllBytes($tmpFile)
            try {
              Invoke-RestMethod -Uri $uploadUrl -Method Put -Headers $uploadHeaders -Body $fileBytes
              Write-Host "Upload successful"
            } catch {
              Write-Host "Upload failed: $($_.Exception.Message)"
              throw
            }
            Remove-Item $tmpFile -ErrorAction SilentlyContinue
            $newUrl = "${env:R2_PUBLIC_BASE_URL}/${key}"
            # Complete job
            $completeHeaders = @{}
            $completeHeaders["x-admin-token"] = $env:SB_ADMIN_TOKEN
            $completeHeaders["Content-Type"] = "application/json"
            $completeBody = @{jobId = $jobId; movieId = $movieId; newUrl = $newUrl; publicId = $key; host = "r2"} | ConvertTo-Json -Compress
            Invoke-WebRequest -Uri "$env:SB_FUNCTION_BASE_URL/complete" -Method Post -Headers $completeHeaders -Body $completeBody | Out-Null
            Write-Host "Completed job $jobId -> $newUrl"
            Remove-Item $hdrCfg -ErrorAction SilentlyContinue
          }
          
          for ($i = 0; $i -lt $count; $i++) {
            $job = $jobs[$i] | ConvertTo-Json -Depth 10
            Process-Job -jobJson $job
          }
